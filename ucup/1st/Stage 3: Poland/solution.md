# The 1st Universal Cup. Stage 3: Poland

## A.Aliases
$(0, 0, 6)$은 조건을 만족하는 해이므로, $a+b+c \le 6$인 모든 경우만 보면 된다. 
$a, b, c$를 확정했을 때 답이 존재하는지는 map 등의 자료구조를 사용해 $O(N \log N)$ 정도에 확인할 수 있다.
시간 제한이 42초이기 때문에 비효율적인 방법을 사용해도 통과할 수 있다.

## B. Bars
$1, N$번 위치는 반드시 선택하는 것이 이득이다.

$l<m<r$인 인덱스 $l, m, r$에 대해 $l, r$이 이미 선택되어 있고, $(l, r)$에는 아무것도 선택되어 있지 않다고 할 때 $m$을 선택하는 것이 이득일 필요충분조건은 $(l, p_l), (r, p_r)$을 잇는 직선 위쪽에 점 $(m, p_m)$이 존재하는 것이다.
따라서 모든 $i$에 대해 $(i, p_i)$를 점을 찍고, 볼록껍질에 들어가는 점들을 전부 선택하면 최적해가 된다.

## C. Ctrl+C Ctrl+V
앞에서부터 보면서 ania가 등장할 때마다 마지막 a를 다른 문자로 바꾸면 된다.

## D. Dazzling Mountain
DFS 순서대로 리프 노드에 번호를 붙이고, 각 정점에 대해 그 정점의 자손인 리프의 구간을 구해준다.
이는 DFS 한 번으로 할 수 있다.
또한 각 정점에 대해 그 정점을 루트로 하는 서브트리 크기를 구하자.

이후 각 크기 $n$에 대해 서브트리의 크기가 $n$인 정점들을 전부 구하고, 그 정점들의 구간 합집합이 전체 구간이 되는지 확인해주면 된다.
이는 구간을 왼쪽 끝 점 기준으로 정렬하여 순서대로 확인하는 것으로 할 수 있다.

이렇게 하면 한 정점은 한 크기 $n$에 해당하는 작업에만 포함되어서 전체 시간복잡도는 $O(N \log N)$이다.

## E. Euclidean Algorithm
주어진 과정을 다음과 같이 생각할 수 있다.
* 초기에 수직선에 a, b에 점이 찍혀 있다.
* 수직선에 두 점을 골라서 외분점을 찍는 것을 반복한다. 최종 상태에는 $\gcd(a, b)$에 점이 찍혀 있어야 한다.

이 작업에서 점을 최대한 많이 찍는 경우를 생각해본다면, $a, b$를 포함하고 공차가 $|a-b|$인 등차수열에 포함되는 점들이 찍혀 있을 것이다.

이제 조건을 만족하는 $1 \le x<y \le N$의 쌍을 구하자.
$y-x=d$, $g=\gcd(x, y)$를 고정한다면 가능한 쌍으로는 $(g, g+d), (g+d, g+2d), \cdots $이 된다. 즉, 답은 floor sum들의 floor sum 형태가 되고, $\sqrt(N)$ 이상인 부분과 이하인 부분을 나누어 계산하는 것으로 빠르게 풀 수 있다.

풀이에 따라 상수 최적화가 필요한 것으로 보인다.

## F. Flower Garden
조건에서 제시된 두 구간의 크기가 모두 $1$이라면 조건을 다음과 같이 해석할 수 있다.
* $a_i$번 꽃병에 바이올렛이 심겨 있다면 $c_i$도 그렇다.
* $c_i$번 꽃병에 장미가 심겨 있다면 $a_i$도 그렇다.

$3N$개의 꽃병을 정점 집합으로 하고, 모든 조건에 대해 $a_i$에서 $c_i$로 향하는 방향 간선을 포함하는 digraph $G$를 구성하자.
결국 목표는 이렇게 구성된 방향 그래프에서 정점 집합 $S$를 골라서 다음 조건을 만족하도록 하는 것이다.
* $N \le |S| \le 2N$
* $a \in S, \vec{ab} \in E(G)$라면 $b \in S$이다.

즉, $S$는 바이올렛을 심을 꽃병 집합이다.

우선 SCC를 만들고, 역방향 그래프에서 위상정렬을 하자.
다음과 같은 경우가 있다:
* 만약 SCC의 크기가 모두 $N$ 이하라면, 앞서 구한 위상정렬 순서대로 SCC를 하나씩 선택해간다면, 선택한 정점의 개수가 $N$ 이상 $2N$ 이하가 되는 순간이 반드시 온다.
* 크기 $N$ 초과인 SCC는 최대 $2$개 존재할 수 있다. 만약 두 개 존재한다면, 위상정렬 순서대로 SCC를 하나씩 선택해나갈 때 하나의 큰 SCC가 선택되고 나머지 하나가 선택되지 않은 순간에서 선택한 정점의 개수는 $N$ 이상 $2N$ 이하이다.
* 크기 $N$ 초과인 SCC가 정확히 하나 있는 경우, 그 SCC를 포함하는 경우와 포함하지 않는 경우로 나눌 수 있다. 포함하지 않는 경우는 선택하는 정점의 개수가 $2N$개 미만임이 보장되므로, 큰 SCC를 포함하지 않으며 최대한 많은 정점을 선택하는 경우만 보면 된다. 큰 SCC를 포함하는 경우는 정점의 개수가 $N$개 이상임이 보장되므로, 최소한의 정점을 추가하는 경우를 보면 된다.

각 과정은 모두 최대 O(V(G)+E(G))에 확인 가능하다.

이제 주어진 조건들의 구간 크기가 $1$ 초과인 경우를 고려하자.
이는 단순히 모든 $x \in [a_i, b_i], y \in [c_i, d_i]$에 대해 $\bar{xy}$라는 간선을 추가하는 것으로 해석할 수 있고, 세그먼트 트리 형태로 더미 노드를 만들어 간선 개수를 줄이는 잘 알려진 테크닉을 사용하여 $G$를 구성할 수 있다.

## G. Great Chase
도둑이 움직인 시간을 계산하고, 거기에 속도를 곱하여 움직인 총 거리를 계산하자.
도둑이 잡히는 시간은 원점 왼쪽에 있는 경찰과 오른쪽에 있는 경찰이 최초로 만나는 시간이다.
즉, 도둑이 잡히는 시간은 $\min_{p_l<0, p_r>0}\{\frac{p_r-p_l}{v_l+v_r}\}$이다.

이는 답에 대한 이분 탐색으로 구할 수 있다.
답이 $k$ 이상일 필요충분조건은 $p_r-kv_r-p_l-kv_l \le 0, p_l<0, p_r>0$인 두 인덱스 $l, r$이 존재하는 것이다.
따라서 $p_l<0$인 모든 $l$에 대해 $-p_l-kv_l$의 최솟값을, $p_r>0$인 모든 $r$에 대해 $p_r-kv_r$의 최솟값을 구하여 합이 $0$ 이상인지 판정해 주면 된다.

## H. Hyperloop
정해는 후술할 풀이와 조금 다르다고 한다.

우선 메모리 제한이 없을 경우에 대해 문제를 해결하자.

모든 정점을 순서대로 포함하는 cycle이 있다는 조건은 $1, N$을 직접적으로 잇는 간선이 있음을 의미하고, 최단 거리가 최대 $50\,000$임을 의미한다.
따라서 $1$번 정점에서 $N$번 정점으로 이동하는 모든 최단경로에 대해 등장하는 가중치의 종류는 최대 $\sqrt(2 \times 50\,000) \le 350$개이다. (가중치의 종류를 $k$가지라 했을 때 $1+2+\cdots +k \le 50\,000$을 풀어서 구할 수 있다.)

우선 최단 경로에 사용될 가능성이 있는 간선들만 모아 directed acyclic graph를 만들고, 각 정점에 대해 그 정점에서 시작하여 $N$으로 갈 때의 답을 구하자.
한 multiset에서 subset을 제거하고, 제거한 subset보다 사전순으로 앞선 값들을 추가하여 새로운 multiset을 만들 경우, 원래 multiset보다 사전순으로 앞서게 된다.
따라서 한 정점 $v$에서 다음으로 갈 정점 $u$를 정했다면, 그 다음부터는 $u$에서 구한 최적해대로 따라가면 된다.

앞서 구한 DAG에서 $N$에서 가까운 순서대로 답을 구하자.
어떤 정점 $v$에 대해 $v$보다 $N$에 더 가까운 정점들에 대한 답을 알고 있다고 하자.
그렇다면 $v$에서 각 이웃한 정점으로 이동했을 때 $N$에 도달하는 path의 multiset을 알 수 있고, 이들을 단순히 비교하는 방법으로 최적해를 구할 수 있다.

각 정점에 대해 최적해에 가중치가 $a$인 간선이 $b$개 사용된다는 정보를 $(a, b)$ 형태의 pair로 관리한다면, 각 정점의 최적해에는 최대 $350$개의 pair로 구성되며, 사전순으로 어떤 것이 앞서는지는 선형 시간에 구할 수 있다.

그러나 메모리 제한이 적어 모든 정점에 대해 최단 경로를 구성하는 가중치 집합을 관리하는 것은 메모리 제한을 충족하지 않는다.
정점 $v$에서 $u$로 가는 것이 최적해일 경우, $v$의 가중치 집합은 $u$의 가중치 집합에 정확히 한 원소를 추가한 것이 된다.
따라서 이 사실을 이용해 persistent segment tree 형태로 간선 집합을 관리한다면 $O(\lg d)$배 더 큰 시간 복잡도, $O(\sqrt d)$배 더 작은 공간 복잡도에 동작하는 알고리즘을 구성할 수 있다.
이는 주어진 제한 조건을 충족한다.

## I. Investors
모든 구간 $[l, r]$에 대해 inversion 개수를 $C[l][r]$이라 하자.
$l$을 고정한다면 모든 $C[l][r]$은 segment tree를 통해 구할 수 있다.
따라서 전체 $C$ 배열을 $O(N^2 \lg N)$에 구할 수 있다.

$dp[i][j]$를 $[1, i]$ 구간을 최대 $j$개의 구간으로 쪼갤 때의 최소 inversion 개수라 정의하자.
이 dp 배열의 상태 전이 함수는 $C$이고, $C$는 monge array이다.

따라서 분할 정복을 통해 $O(NK \lg N)$에 모든 $dp$ 배열을 채울 수 있다.

## J. Job for a Hobbit
우선 $NK$개의 원소를 다음 조건을 충족하도록 정렬할 수 있다.
* 한 pole 안에서는 아래에 있는 원소가 가장 작고, 비내림차순으로 정렬되어 있다.
* $i$번 pole의 맨 위의 원소는 $i+1$번 pole의 맨 아래 원소보다 작거나 같다.

가장 먼저 해야 할 것은 한 pole 안에 있는 원소를 정렬하는 것이다.
우선 각 $i$에 대해 $1, \cdots, i$번 pole을 차례로 하나씩 왼쪽으로 옮기고, $N, \cdots, i+1$번 pole을 차례로 하나씩 오른쪽으로 옮겨 $i$, $i+1$번 pole을 비게 만든다.
이후 $i-1$번 pole(원래는 $i$번 pole에 있던 것)이 빌 때까지 다음을 반복하면 된다.
* $i-1$번 pole의 원소들을 위쪽에서부터 순차적으로 보면서 최솟값을 가지는 원소를 $i$번 pole로 옮기고, 아닌 것을 $i+1$번 pole로 옮긴다.
* $i+1$번 pole에 있는 원소들을 전부 $i-1$번 pole로 가져온다.

이제 본격적으로 전체 배열을 정렬한다. 
기본적인 아이디어는 버블 정렬이다. 
어떤 인덱스 $i$ 대해 전체 배열에 $i, i+1$번 pole의 원소들만 있다고 생각하면 두 pole의 원소들이 정렬되어 있음을 사용해 정렬할 수 있다. (디테일이 약간 복잡하나, 여기서는 생략한다.)

$i=1, 2, \cdots, N-1$에 대해 위 과정을 시행한다. 그렇다면 전체 배열에서 가장 큰 $K$개의 원소는 $N$번 pole에 모이게 된다.
따라서 이를 총 $N$번 시행해준다면 배열을 정렬할 수 있게 된다.

배열을 정렬한 이후에는 같은 원소가 인접한 구간에만 속해 있다는 사실을 이용해서 문제에서 제시된 조건을 만족하도록 할 수 있다.

## K. Kooky Tic-Tac-Toe
단순 구현 문제이다.
크게 다음과 같은 방식으로 풀 수 있다.
* 마지막으로 두어졌을 수를 확정한다.
* 해당 수를 게임판에서 제거했을 때 게임이 끝난 상태가 아니어야 한다. 이를 확인한다.
* 최종 게임판은 누군가 승리한 상황이거나, 모든 칸이 차 있는 상태여야 한다.
* 마지막 수가 두어지기 전과 후에 대해 게임판에 있는 o와 x의 개수가 최대 $1$ 차이나야 한다.
* 만약 모든 조건을 만족했다면, 해당 수를 마지막 수로 하는 아무 수순이나 출력하면 된다.

## L. Line Replacements
